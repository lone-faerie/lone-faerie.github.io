---
layout: post
title: rcopy
author: lone-faerie
date: 2024-02-25 18:17:47 -0800
tags:
  - c
  - networks
  - linux
  - school
---
### Remote file copy for CPE 464 - Introduction to Computer Networks
<!--more-->
[![Download](https://img.shields.io/badge/.tar.gz-download-blue?color=%23b5e853&logo=data:image/svg%2bxml;base64,{{ site.data.icons.download.base64 }})](/assets/rcopy.tar.gz)
* * *
This program is a remote file copy command using UDP. It consists of both a client and server program to copy files from the client to the server. Flow control and error recovery are handled with a custom selective reject implementation. Network communication has errors artificially added to ensure they are properly handled.
* * *
Rcopy is implemented as a state machine using function pointers, with a signature of `void* (*state_fn)(struct connection*, uint32_t, int)`, the arguments are the connection struct, the window size, and the buffer size, and the return value is the function pointer for the next state, or `NULL` if done.

The server is also implemented as a state machine using function pointers, with a signature of `void* (*state_fn)(struct connection*, uint32_t*, uint32_t*)`, the arguments are the connection struct, a pointer to the expected sequence number, and a pointer to the highest sequence number, and the return value is the function pointer for the next state, or `NULL` if done.

The PDU format for sending the filename to the server is the 32 bit window size in network order, the 16 bit buffer size in network order, and the file name. When the server receives the filename packet, it initializes its buffer and opens the file. The response packet contains a 32-bit integer in network order, which is 0 if the file was opened successfuly, or any error returned by opening the file.

`application.h` and `application.c` define macros and helper functions common to both rcopy and the server. The primary functions are `int openSocket(struct connection* conn)` which opens a new socket for the provided connection, and closes the old socket if one was open, and `int mustRecv(struct connection* conn, flag_t* flag, uint8_t** buf, int* len, int timeout, timeout_cb f)`, which handles safely receiving packets. If it times out before receiving a packet, the provided callback function is run (usually resending a packet) and it retries, up to 10 times. If it receives a packet with an invalid checksum, it throws the packet away and polls for the next one.