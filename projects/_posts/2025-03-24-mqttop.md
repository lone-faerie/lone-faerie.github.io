---
layout: post
title: MQTTop
author: lone-faerie
date: 2025-03-24 12:58:00 -0800
repository: mqttop
tags:
  - go
  - mqtt
  - linux
  - docker
  - home-assistant
---
{% assign repo = site.github.public_repositories | where:"name",page.repository | first %}
#### {{ repo.description }}
<!--more-->
[![Github](https://img.shields.io/badge/github-blue?logo=github&color=%23555)]({{ repo.html_url }})
[![Download](https://img.shields.io/badge/.zip-download-blue?color=%23b5e853&logo=data:image/svg%2bxml;base64,{{ site.data.icons.download.base64 }})]({{ repo.html_url }}/archive/refs/heads/main.zip)

* * *
MQTTop is a bridge to provide top-like system metrics over MQTT. This was mainly designed for use with [Home Assistant](https://www.home-assistant.io) and supports MQTT Discovery, and has currently been tested on Linux and with an NVIDIA GPU.

Inspired by [btop](https://github.com/aristocratos/btop) and [linux2mqtt](https://github.com/miaucl/linux2mqtt)
* * *
I wanted to add system metrics into my Home Assistant instance for a remote device, but none of the existing solutions exactly met my needs so I built this program. It is able to provide metrics for CPU usage, memory usage, disk usage, directory size, network connection, battery level, and NVIDIA GPU usage. MQTTop makes use of procfs and sysfs to retrieve most of the metrics, as well as inotify for directories and the NVML library for NVIDIA GPU metrics. The MQTT connection is handled by the paho client library with added support for Home Assistant discovery.

MQTTop is written in Go with a focus on being as lightweight as possible. Metrics are implemented as an interface, allowing for easy extensibility, and each metric runs in a separate goroutine. They are coordinated through an MQTT bridge, reporting new metrics through channels. This allows for metrics to be published as soon as they update, without needing to interrupt any other metrics. The metrics that are able trigger with callbacks, such as directory metrics, and the rest use polling. By rate limiting the callbacks and only publishing when there are changes, this helps to avoid flooding the network. The program can be run from the command line or through Docker, with builds both with and without GPU support so reliance on proprietary libraries is optional. Configuration is done through YAML files, command line arguments, and/or environment variables, allowing for the most flexibility.