---
layout: post
title: TinyFS
author: lone-faerie
date: 2024-05-27 21:43:00 -0800
repository: tinyfs
tags:
  - c
  - os
  - linux
  - school
---
{% assign repo = site.github.public_repositories | where:"name",page.repository | first %}
#### File system for CSC 453 - Introduction to Operating Systems
<!--more-->
[![Github](https://img.shields.io/badge/github-blue?logo=github&color=%23555)]({{ repo.html_url }})
[![Download](https://img.shields.io/badge/.zip-download-blue?color=%23b5e853&logo=data:image/svg%2bxml;base64,{{ site.data.icons.download.base64 }})]({{ repo.html_url }}/archive/refs/heads/main.zip)
* * *
TinyFS is a filesystem built on top of a library which emulates a block device on a unix file. The filesystem supports opening, creating, closing, deleting, reading, writing, and seeking files. It also supports making files read-only or read/write and renaming files. Additionally, TinyFS supports hierarchical directories, in both creation and deletion, as well as printing the directory tree to the terminal.
* * *
This implementation has two main typedefs, Block and File, in addition to the required fileDescriptor, though these two structs aren't exposed to the user. Block is a struct used for holding block data in memory. It contains the block number, a buffer of BLOCKSIZE bytes, and a modified flag for determining if the block needs to be written back to the disk. File is a struct used for keeping track of the state of open files. It contains the file's inode's block number, as well as its parent directory's inode  block number, an 8 byte buffer for the filename, the file size, flags, the current pointer, as well as a Block used for buffering. 

A global Block is used for keeping the superblock in memory, and a global File is used for keeping the root directory memory.A global slice of File structs is used for the open file table (see below). Additionally, two globals, nextFD and nextBlock, are for quick access to a free file descriptor or block after one has been closed or freed. They are set once a file descriptor or block has been freed.

After the file descriptor from nextFD is used, the next free file descriptor is found by iterating through the open file table for any Files that have been freed by setting their inode block number to 0. If there are none, a new File is appended and the file descriptor is the last index of the open file table. After the block number from nextBlock is used, the next free block is found by determining the first set bit in the superblock's bitmap. This is done with the __builtin_ctz() function of gcc to perform a "count trailing zeros" operation, on the first non-zero word of the bitmap.

Blocks are addressed using a single byte, which limits the maximum disksize for this filesystem to 256 blocks, or 65,536 bytes. Any errors returned internally by libDisk are immediately returned to the user. The additional features implemented were hierarchical directories, as well as directory listing and file renaming, and read-only and writeByte support.